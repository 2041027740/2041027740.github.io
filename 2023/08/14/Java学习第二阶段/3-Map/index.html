<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="空灵">
<meta property="og:type" content="article">
<meta property="og:title" content="3_Map">
<meta property="og:url" content="http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/index.html">
<meta property="og:site_name" content="星辰可染呀">
<meta property="og:description" content="空灵">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201121211877.png?align=center">
<meta property="og:image" content="http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/img/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/img/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png">
<meta property="article:published_time" content="2023-08-14T00:30:08.000Z">
<meta property="article:modified_time" content="2023-08-14T00:56:57.972Z">
<meta property="article:author" content="染星辰">
<meta property="article:tag" content="Map">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201121211877.png?align=center">


<link rel="canonical" href="http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/","path":"2023/08/14/Java学习第二阶段/3-Map/","title":"3_Map"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>3_Map | 星辰可染呀</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星辰可染呀</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">恰似人间惊鸿客，墨染星辰云水间</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="nav-text">前置准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">Map是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-text">API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap"><span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-text">准备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHash"><span class="nav-text">什么是Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%BD%E7%9A%84Hash%E7%AE%97%E6%B3%95%E5%B8%8C%E6%9C%9B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">好的Hash算法希望的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E7%9A%84%E5%B9%82%E5%8F%96%E4%BD%99%E9%97%AE%E9%A2%98"><span class="nav-text">2的幂取余问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text">HashMap的底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">HashMap的一些注意事项(面试题)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E5%8F%8A%E6%89%A9%E5%AE%B9"><span class="nav-text">&#x3D;&#x3D;初始化容量及扩容&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="nav-text">加载因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84"><span class="nav-text">HashMap底层数组结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">hash的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89HashMap%E5%AF%B9%E9%87%8D%E5%A4%8D%E7%9A%84key%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">&#x3D;&#x3D;（重要）HashMap对重复的key的定义&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">存储重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">链表什么时候转化为红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E9%93%BE%E8%A1%A8%E6%95%B0%E7%9B%AE%E4%BB%8E8%E5%88%B0%E8%BE%BE9%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%97%EF%BC%9F"><span class="nav-text">当链表数目从8到达9，一定会转化为红黑树吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E5%90%8E%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="nav-text">扩容后位置问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-text">红黑树转化为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%9C%A8HashMap%E5%B7%B2%E7%BB%8F%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%BB%BDkey-value%E6%95%B0%E6%8D%AE-%E5%BB%BA%E8%AE%AE%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E5%86%8D%E9%80%9A%E8%BF%87key%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9key-%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%97%A0%E6%B3%95-%E5%86%8D%E6%93%8D%E4%BD%9C%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE-%E4%BA%86%E8%A7%A3"><span class="nav-text">如果我们在HashMap已经添加了一份key-value数据,  建议尽量不要再通过key的引用直接修改key,  有可能会无法 再操作这个数据 (了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89HashMap%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%B5%81%E7%A8%8B"><span class="nav-text">&#x3D;&#x3D;（重要）HashMap的添加流程&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">HashMap的构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E7%9A%84API"><span class="nav-text">HashMap的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E8%A3%85%E6%95%B0%E6%8D%AE"><span class="nav-text">组装数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hashtable"><span class="nav-text">Hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedHashMap"><span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">LinkedHashMap的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">LinkedHashMap的构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap%E7%9A%84api"><span class="nav-text">LinkedHashMap的api</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TreeMap"><span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">TreeMap的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">TreeMap的构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap%E7%9A%84api"><span class="nav-text">TreeMap的api</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Properties"><span class="nav-text">Properties</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">染星辰</p>
  <div class="site-description" itemprop="description">一生温暖纯良，不舍爱与自由</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/3-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="染星辰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰可染呀">
      <meta itemprop="description" content="一生温暖纯良，不舍爱与自由">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="3_Map | 星辰可染呀">
      <meta itemprop="description" content="空灵">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          3_Map
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-14 08:30:08 / 修改时间：08:56:57" itemprop="dateCreated datePublished" datetime="2023-08-14T08:30:08+08:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E8%AF%BE%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">java学习第二阶段课件</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">空灵</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>学习目标：</p>
<ul>
<li>会使用Map的增删改查API。遍历Map的方式</li>
<li><span style=color:yellow;background:red><strong>掌握HashMap存储数据的特点</strong></span></li>
<li><span style=color:red;background:yellow><strong>熟练掌握对常见的场景进行Map的使用</strong></span>.你的业务怎样需要，Map的key和value就可以怎样定义。</li>
<li><span style=color:yellow;background:red><strong>掌握HashMap的底层结构（面试）</strong></span></li>
<li><span style=color:yellow;background:red><strong>掌握HashMap的添加一份key-value数据的流程</strong></span></li>
<li><span style=color:yellow;background:red><strong>掌握HashMap的初始化容量及扩容机制，对重复的key的定义</strong></span></li>
<li>掌握LinkedHashMap和TreeMap存储数据的特点</li>
</ul>
<p><span style=color:yellow;background:red><strong>重点，难点，面试常考点</strong></span></p>
<p>面试的时候问集合。 90%会问到HashMap。</p>
<p>是否了解List接口，Set接口，Map接口。</p>
<p>是否了解List的子类。有什么特点？数组和链表。</p>
<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="Map是什么"><a href="#Map是什么" class="headerlink" title="Map是什么"></a>Map是什么</h2><p>什么是Map呢？Map就是用来存储键值对的接口，注意，它与Collection的区别。Collection存储的是单列数据，Map存储的键值对。什么叫键值对。就是一个key，一个value。我们举一个生活中的例子，我们把一些常见的公共电话与它的功能做一个对应。</p>
<p>比如 110 是警察局</p>
<p>120 是医院</p>
<p>119 是火警</p>
<p>122 是车辆救援</p>
<p>12345 是消费者权益保护。用一个键，可以快速获取一个值。</p>
<p>比如，如果我们想在1-20中间随机生成10000个数，需要记录每个数生成了多少次，怎么存呢？</p>
<p><font color=red><strong>生成1-20之间的随机数，10000个数字。</strong></font></p>
<p>那如果是 1-10_000_000中间生成1000次呢？</p>
<p>使用数组实现不现实。 如果是int范围内生成呢？</p>
<p>需要使用Map。</p>
<p>等学完了Map的API，实现一下。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Map是Map体系的顶级接口，用来存储键值对数据</li>
<li>Map存储的数据，有一些子接口有序，有一些无序</li>
<li>Map存储的数据，不能重复（指的是key）</li>
<li>Map存储的数据，有一些允许为null，有一些不允许。（指的key）</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------新增，删除，查找数据接口</span></span><br><span class="line"><span class="comment">//    V put(K key, V value): 添加键值对。 如果键存在，是更新数据</span></span><br><span class="line"><span class="comment">//    void putAll(Map&lt;? extends K,? extends V&gt; m)： 将一个map的所有键值对都放入这个map</span></span><br><span class="line"><span class="comment">//    V get(Object key)： 根据一个key，获取value，如果key不存在，返回null</span></span><br><span class="line"><span class="comment">//    V remove(Object key)： 删除map中所包含的这个key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    boolean containsKey(Object key): 判断map中是否包含这个key</span></span><br><span class="line"><span class="comment">//    boolean containsValue(Object value): 判断map中是否包含这个value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------辅助接口</span></span><br><span class="line"><span class="comment">//    void clear() : 清空map</span></span><br><span class="line"><span class="comment">//    boolean equals(Object o)： 判断两个map是否相等</span></span><br><span class="line"><span class="comment">//    int hashCode(): 返回此映射的哈希码值。</span></span><br><span class="line"><span class="comment">//    boolean isEmpty(): map中是否有元素</span></span><br><span class="line"><span class="comment">//    int size() ：返回键-值映射关系数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------视图方法</span></span><br><span class="line"><span class="comment">// 在Map里面 Entry 代表存储了key和value的一个接口体</span></span><br><span class="line"><span class="comment">//    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()： 返回此映射中包含的映射关系的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Set&lt;K&gt; keySet()： 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Collection&lt;V&gt; values()： 返回此映射中包含的值的 Collection 视图。</span></span><br></pre></td></tr></table></figure>





<p><span style=color:red;background:yellow><strong>实现一下这个</strong></span></p>
<p>如果我们想在1-20中间随机生成10000个数。怎么存？</p>
<p>1-10_000_000中间生成1000次？</p>
<p>班级里有一些学生，我想根据省份进行分组，应该怎么做？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title function_">generateStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; provinceList = Arrays.asList(<span class="string">&quot;hubei&quot;</span>, <span class="string">&quot;hunan&quot;</span>, <span class="string">&quot;guangdong&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            student.setName(<span class="string">&quot;student&quot;</span> + i);</span><br><span class="line">            student.setAge(<span class="number">15</span>);</span><br><span class="line">            <span class="comment">// 从省份的list中，获取出一个省份，设置到学生上</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">province</span> <span class="operator">=</span> provinceList.get(i % <span class="number">3</span>);</span><br><span class="line">            student.setProvince(province);</span><br><span class="line"></span><br><span class="line">            students.add(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String province;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><span style=color:yellow;background:red><strong>要学会完成抽象化的任务</strong></span></p>
<ul>
<li>比如你想统计一个班上每个省份的学生人数。应该怎么设计这个Map？</li>
<li>想统计一个班上，男生和女生的人数</li>
<li>一个班级的，语文分按照 [0,60), [60,80), [80,100]分三个层级 差，良，优秀。怎么统计每个层级的人数？(抽方法有什好处)</li>
</ul>
<p>Map进行增删改查的API</p>
<p>遍历Map的key-value数据的方式</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h3><p>映射（函数）的概念：</p>
<blockquote>
<p>设A和B是两个非空集合，并存在某种对应关系f</p>
<p>按照这种对应关系f，对于集合A中的任何一个元素a，在集合B中都存在<font color=red><strong>唯一的</strong></font>一个元素b与之对应</p>
<p>那么，这样的对应（包括集合A，B，以及集合A到集合B的对应关系f）叫做集合A到集合B的映射</p>
<p>y&#x3D;f(x)。 一个x对应一个y。 一个y可能对应多少个x。</p>
<p>对于一个x，只能有一个y与之对应</p>
<p>对于一个y，可以有多个x与之对应。</p>
<p>映射。 对于一个x，只能有一个y；对于一个y,可能有多个x</p>
</blockquote>
<img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201121211877.png?align=center" alt="映射图解" style="zoom:33%;" />

<p>注意：</p>
<ol>
<li><span style=color:red;background:yellow><strong>映射不要求元素一一对应，允许出现多对一，但绝不允许一（x）对多(y)。</strong></span></li>
</ol>
<hr>
<p>明白映射的概念后，哈希映射(hash)就不难理解了。哈希映射也是一种特殊的映射，要求：</p>
<ol>
<li>集合A（x）必须是一个无限大小，具有无穷多元素的集合。</li>
<li>集合B(y)必须是一个元素有限的集合。</li>
</ol>
<p>x是无限的，y是有限的。  一定会出现，一个y对应多个x。</p>
<p>y&#x3D;f(x)</p>
<p><code>化无限为有限</code>，这就是哈希映射。将<strong>任意长度的输入</strong>通过散列算法变换成<strong>固定长度的输出</strong>。</p>
<p>在哈希映射当中，集合A和B之间的对应关系f，就是一种映射的规则，称之为<code>哈希函数</code>、<code>哈希方法</code>或者<code>哈希算法</code>等。</p>
<p>而通过哈希算法，求得的集合B中的元素，称之为<code>哈希值</code>。</p>
<h3 id="好的Hash算法希望的特点"><a href="#好的Hash算法希望的特点" class="headerlink" title="好的Hash算法希望的特点"></a>好的Hash算法希望的特点</h3><p>y&#x3D;f(x).也希望尽可能的均匀。</p>
<p>因为输入是无限数目的。而hash算法的结果(hash值)是有限的。所以肯定会遇到碰撞(hash值相同)。</p>
<p><span style="font-size:20px;color:red;">好的hash算法希望对于不同的输入，得到不同的输出结果。</span></p>
<h3 id="2的幂取余问题"><a href="#2的幂取余问题" class="headerlink" title="2的幂取余问题"></a>2的幂取余问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先说一个结论 </span></span><br><span class="line"><span class="comment">// 1.当 b 是2的幂次。则  a % b =  a &amp; (b-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 25 % 16</span></span><br><span class="line"><span class="comment">// 25 % 16 </span></span><br><span class="line"><span class="comment">// = 11001 % 10000</span></span><br><span class="line"><span class="comment">// = 11001 &amp; (10000-1)			 </span></span><br><span class="line"><span class="comment">// = 11001 &amp; 01111</span></span><br><span class="line"><span class="comment">// = 01001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.当b是2的幂次， a%b 相当于是取a的低位。</span></span><br><span class="line"><span class="number">53</span> % <span class="number">16</span> = （<span class="number">0011</span> <span class="number">0101</span>） % （<span class="number">0001</span> <span class="number">0000</span>） =（<span class="number">0011</span> <span class="number">0101</span>） &amp; （<span class="number">0000</span> <span class="number">1111</span>）   = <span class="number">0101</span></span><br></pre></td></tr></table></figure>

<h2 id="HashMap的底层结构"><a href="#HashMap的底层结构" class="headerlink" title="HashMap的底层结构"></a>HashMap的底层结构</h2><p>HashMap底层结构是数组+链表+红黑树。</p>
<p><strong>HashMap的底层结构是一个数组。</strong> 想往HashMap中添加一个键值对。要经过哪些流程呢？</p>
<ul>
<li>首先，会对键，计算得到一个int类型的值<font color=red><strong>(其实就是hash的过程)</strong></font></li>
<li>然后与数组长度取余，得到键在数组上的位置。（为什么要取余， 因为整数太大了，数组不一定能存下。 ）</li>
<li>如果数组位置上没有元素，则直接插入</li>
<li>如果数组位置上有元素，<font color=red><strong>这个时候怎么操作呢？</strong></font>我们采用的链表，存储落在同一个位置上的元素。挨个比较，比较完成后，如果没有就插入到链表的最后一个位置</li>
</ul>
<p><span style="font-size:20px;color:red;">链表太长了有什么问题？</span></p>
<p>效率太低，因为比如链表有1w个节点，那就要比较1w次。效率差。所以链表太长了时会转化为<span style="font-size:20px;color:red;">红黑树。</span></p>
<p>面试题： 为什么HashMap的底层，是数组+链表+红黑树？</p>
<p>把添加的流程答出来，然后分析，链表是必不可少的（因为存在多个key落在同一个数组位置）。如果链表长度太长，这时候，效率太差，采用红黑树提高效率。</p>
<p>答面试题，一定要注意，听懂面试官的问题。你要知道他在考你什么。</p>
<p>有的时候，如果就是没听懂，怎么办？</p>
<div align="center"><img src="./img/HashMap底层结构.png"></div>

<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol>
<li>HashMap是Map接口的子实现。用来存储key-value数据</li>
<li>底层结构，是数组+链表+红黑树</li>
<li>数组默认长度16，扩容机制是2倍。（数组的长度一直是2的幂次方，  a%b &#x3D; a&amp;(b-1)）</li>
<li>存储元素是无序的。对于key来说的</li>
<li>不允许存储重复元素， <span style=color:red;background:yellow><strong>重复是指的它的键</strong></span></li>
<li>允许存储null。对于key来说的</li>
</ol>
<p>为什么HashMap的底层是数组+链表+红黑树。</p>
<p>错误答法：不知道。写JDK那帮人写得。</p>
<p>如果不知道，可以说不知道。但是不要说的这么理所当然。</p>
<p>一定要注意一个问题。 面试的时候，要去理解记忆。不要一股脑全背出来。</p>
<h2 id="HashMap的一些注意事项-面试题"><a href="#HashMap的一些注意事项-面试题" class="headerlink" title="HashMap的一些注意事项(面试题)"></a>HashMap的一些注意事项(面试题)</h2><h3 id="初始化容量及扩容"><a href="#初始化容量及扩容" class="headerlink" title="&#x3D;&#x3D;初始化容量及扩容&#x3D;&#x3D;"></a>&#x3D;&#x3D;初始化容量及扩容&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap的底层是数组+链表+红黑树。</span></span><br><span class="line"><span class="comment">// 数组默认长度是16。 扩容机制2倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以说明 </span></span><br><span class="line"><span class="comment">//     1.数组长度一直都是2的幂次。说明  a%b=a&amp;(b-1)</span></span><br><span class="line"><span class="comment">// 我们的第二步，对计算得到的int值，对数组长度进行取余。 可以转换以下  hash % length = hash &amp; (length - 1)</span></span><br></pre></td></tr></table></figure>



<h3 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a>加载因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap底层是数组+链表+红黑树。如果不限制，其实可以存无限的数据，但是这样效率较低</span></span><br><span class="line"><span class="comment">// 在HashMap底层维护的了一个加载因子，用来表示存储到多少就会扩容</span></span><br><span class="line"><span class="comment">// 比如默认的数组长度是16。 加载因子是0.75f</span></span><br><span class="line"><span class="comment">// 阈值 = 16 * 0.75（加载因子） = 12</span></span><br><span class="line"><span class="comment">// HashMap存储的key-value数据数目超过 阈值, 就要引发数组扩容</span></span><br><span class="line"><span class="comment">// key-value键值对的数目，包括链表上挂着的东西。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子是控制什么事情？ 主要是控制数组上能存储的数据。</span></span><br><span class="line"><span class="comment">// 加载因子。不建议大家调整。JDK 0.75 结合工程实践，对很多场景进行测试。所以loadFactor不建议大家调整。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">//           resize();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//															0.75*16</span></span><br><span class="line"><span class="comment">//  threshold = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考一下，添加数据的效率，查找数据的效率，删除数据的效率。 大概是多少？</span></span><br></pre></td></tr></table></figure>

<h3 id="HashMap底层数组结构"><a href="#HashMap底层数组结构" class="headerlink" title="HashMap底层数组结构"></a>HashMap底层数组结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap底层数组存储的key-value 是以Node结点存储的</span></span><br><span class="line"><span class="comment">// 里面存储了四个东西， key值 value值 hash 下一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    K key,</span><br><span class="line">    V value,</span><br><span class="line">    <span class="type">int</span> hash,</span><br><span class="line">    Node next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node[] </span><br></pre></td></tr></table></figure>



<div align="center"><img src="./img/HashMap底层结构.png"></div>

<h3 id="hash的计算"><a href="#hash的计算" class="headerlink" title="hash的计算"></a>hash的计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key==null  </span></span><br><span class="line">    <span class="comment">// 1.为null的时候，返回0</span></span><br><span class="line">    <span class="comment">// 2.不为null。 返回后面的。</span></span><br><span class="line">    <span class="comment">// (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    <span class="comment">// 首先计算hashCode。赋值给h。  h无符号右移16位，  再取异或。</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么要这样写。  直接hashCode，代码也能跑。为啥要  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.当b是2的幂次， a%b 相当于是取a的低位。</span></span><br><span class="line"><span class="comment">// 53 % 16 = （0011 0101） % （0001 0000） =（0011 0101） &amp; （0000 1111）   = 0101</span></span><br><span class="line"><span class="comment">// 如果是直接计算hashCode.  那最后得到的下标，只有低位会参与。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设hashCode </span></span><br><span class="line"><span class="comment">// 有一个key 的hashCode：  0101 1010 </span></span><br><span class="line"><span class="comment">// 还有个keyu  hashCode   1101  1010</span></span><br><span class="line"><span class="comment">// 对16进行取余。 </span></span><br><span class="line"><span class="comment">// 也可以思考一下： 为什么使用的是 ^;   为什么没有用这两个 &amp;  |</span></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash() 就是为了计算给定的key的int值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key == null</span></span><br><span class="line">    <span class="comment">// 如果key为null的时候，返回0</span></span><br><span class="line">    <span class="comment">// 如果key不为null。 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算hashCode. h=hashCode </span></span><br><span class="line">    <span class="comment">// (h) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    <span class="comment">// 就是为了让计算 得到下标的时候。高位和低位同时生效。</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a % b = a &amp; (b-1)</span></span><br><span class="line"><span class="comment">//  0010 0111 0110 0110(10086)</span></span><br><span class="line"><span class="comment">//&amp; 0000 0000 0000 1111 </span></span><br><span class="line"><span class="comment">// a和b取余的时候。 谁生效  低位生效</span></span><br><span class="line"></span><br><span class="line">(hashCode) ^ (hashCode &gt;&gt;&gt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于任意一个输入，我们需要得到一个数字与之对应</span></span><br><span class="line"><span class="comment">// 如果key为null，则直接返回0</span></span><br><span class="line"><span class="comment">// 如果key不为null。首先计算hashCode。然后hashCode无符号右移动16位，然后与原数取异或。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是为了充分混合，让key落得位置更加均匀。</span></span><br><span class="line"><span class="comment">//  数组长度是2的幂次。   对这个2的幂次取余，最终起效果的就是数字的 后面位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，计算得到的hash值是77。 </span></span><br><span class="line"><span class="comment">// 当数组底层长度是n的时候。计算得到的下标： </span></span><br><span class="line"><span class="comment">// 16:  77(0100 1101) % 16(0001 0000) </span></span><br><span class="line"><span class="comment">//      77(0100 1101) &amp; (0000 1111)</span></span><br><span class="line"><span class="comment">// 	=  0100 1101 &amp; 0000 1111 = 1101    (就是最后四位，取的低位)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候，高位和低位取个异或，会让高位和低位对在数组上的下标起作用</span></span><br></pre></td></tr></table></figure>

<h3 id="（重要）HashMap对重复的key的定义"><a href="#（重要）HashMap对重复的key的定义" class="headerlink" title="&#x3D;&#x3D;（重要）HashMap对重复的key的定义&#x3D;&#x3D;"></a>&#x3D;&#x3D;（重要）<span style="color:red;">HashMap对重复的key的定义</span>&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span></span><br><span class="line"><span class="comment">// p就是 当前数组位置的元素。 Node( hash  key  value  next)</span></span><br><span class="line"><span class="comment">// 如果你传入的key， 计算得到的hash和  数组上元素的hash相同。 这时候才会进入后面的逻辑。</span></span><br><span class="line"><span class="comment">// ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span></span><br><span class="line"><span class="comment">// 如果传入的key和我数组上的key 是同一个(地址相同) ；    或者equals返回true，也认为是相同的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果key等于null的时候呢？</span></span><br><span class="line"><span class="comment">// 在前面的代码已经判断出来了。 (k = p.key) == key</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p指的是原本存在的元素</span></span><br><span class="line"><span class="comment">// hash 是我们传入的hash值（int）  key</span></span><br><span class="line"><span class="comment">// (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.hash值相同，才往下判断</span></span><br><span class="line"><span class="comment">// 2.如果地址相同。  ||  如果equals返回相同，</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// 为什么需要重写？ </span></span><br><span class="line"><span class="comment">// 比如，现在使用自定义的类 User(name, age)作为key。</span></span><br><span class="line"><span class="comment">// 为什么必须要重写hashCode和equals方法？</span></span><br><span class="line"><span class="comment">// 1.计算int值。计算int  hashCode。</span></span><br><span class="line"><span class="comment">// 2.代码这里，怎么判断相等的？ new User(&quot;zs&quot;, 18);  new User(&quot;zs&quot;, 18)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这就要求我们，使用一些类作为key时。<span style=color:red;background:yellow><strong>必须同时重写hashCode和equals方法。</strong></span></li>
<li><span style=color:red;background:yellow><strong>不建议大家使用自定义的类当做key。一般使用字符串或者Integer。</strong></span></li>
</ul>
<h3 id="存储重复元素"><a href="#存储重复元素" class="headerlink" title="存储重复元素"></a>存储重复元素</h3><p>map.put(“zs”, “hubei”);</p>
<p>map.put(“zs”, “hunan”);</p>
<p>HashMap不允许存储重复的key, 当我们存储一份重复的key-value数据时,   是直接用新value是替代旧value，然后，返回了旧值。</p>
<h3 id="链表什么时候转化为红黑树"><a href="#链表什么时候转化为红黑树" class="headerlink" title="链表什么时候转化为红黑树"></a>链表什么时候转化为红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当某个下标位置, 链表长度, 超过8达到9个时候(算上新加的结点), 就要由链表转化为红黑树</span></span><br></pre></td></tr></table></figure>

<h3 id="当链表数目从8到达9，一定会转化为红黑树吗？"><a href="#当链表数目从8到达9，一定会转化为红黑树吗？" class="headerlink" title="当链表数目从8到达9，一定会转化为红黑树吗？"></a>当链表数目从8到达9，一定会转化为红黑树吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不一定会</span></span><br><span class="line"><span class="comment">// 如果数组的长度小于64.直接resize 扩容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组长度, 小于64,  即使某个下标位置,链表长度已经超过8, 达到9了, 不会转化为红黑树, 而是扩容, 扩容会导致原本存在于这个位置的数据, 拆成两部分</span></span><br></pre></td></tr></table></figure>

<p><span style="font-size:20px;color:red;">思考一下，为什么这么设计？</span></p>
<p>当链表的长度，到达9的时候，会转化为红黑树。</p>
<p>数组长度是32。是最大的情况。</p>
<p>当前位置，有9个元素。其他31个位置，假设已经有12个元素。阈值是32*0.75&#x3D;24.</p>
<p>当前元素，有 9 +12 &#x3D; 21。所以，过一会，可能就扩容了。</p>
<p>与其现在把链表转换为红黑树，等会扩容了又会变成链表，不如我直接扩容。设计者认为这样设计，可以提高效率。</p>
<h3 id="扩容后位置问题"><a href="#扩容后位置问题" class="headerlink" title="扩容后位置问题"></a>扩容后位置问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在，假设位置在x位置上的元素，扩容之后会落到新数组的什么位置</span></span><br><span class="line"><span class="comment">// 旧数组的容量  16</span></span><br><span class="line"><span class="comment">// 新数组的容量 32</span></span><br><span class="line"><span class="comment">// hash % 16 = x   ==&gt;    hash = x + 16 * n</span></span><br><span class="line"><span class="comment">// hash % 32   =  (x + 16 * n) % 32 = x  或者  x+16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x = hash % Oldlen = hash % 16</span></span><br><span class="line"><span class="comment">// 用x把hash表示出来。    hash = x + 16 * n</span></span><br><span class="line"><span class="comment">// 现在落在新数组什么位置： hash % 32 = (x + 16 * n) % 32 = x + 16 ; x </span></span><br><span class="line"><span class="comment">// 所以说，就只能落在两种位置： 要么原index位置，要么index + oldCapacity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HashMap中, 存储的数据量大于HashMap的阈值(加载因子*数组长度), 会产生扩容,  当扩容之后一个原本在旧数组x位置的key-value数据,   要和新数组长度取模,得到一个新的下标, 这个新的下标只有两个选择:  x位置, 旧数组长度+x的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩2倍。</span></span><br></pre></td></tr></table></figure>

<h3 id="红黑树转化为链表"><a href="#红黑树转化为链表" class="headerlink" title="红黑树转化为链表"></a>红黑树转化为链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有两个情况:</span></span><br><span class="line"><span class="comment">// 第一个情况, 删除数据的时候;  要删除的数据在红黑树上,  删除数据导致红黑树上数据量变少,  由红黑树转化为链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个情况: 扩容的时候, 一个红黑树再扩容之后, 被拆成两部分, 任一部分数据量过少, 也会由红黑树转化为链表</span></span><br><span class="line"><span class="comment">//    红黑树拆成低位(旧位置)和高位(旧位置+旧数组长度: 新位置)两部分, 这两部分, 任何一部分分配的数据量小于等于6个, 就要由红黑树转化为链表</span></span><br></pre></td></tr></table></figure>



<h3 id="如果我们在HashMap已经添加了一份key-value数据-建议尽量不要再通过key的引用直接修改key-有可能会无法-再操作这个数据-了解"><a href="#如果我们在HashMap已经添加了一份key-value数据-建议尽量不要再通过key的引用直接修改key-有可能会无法-再操作这个数据-了解" class="headerlink" title="如果我们在HashMap已经添加了一份key-value数据,  建议尽量不要再通过key的引用直接修改key,  有可能会无法 再操作这个数据 (了解)"></a>如果我们在HashMap已经添加了一份key-value数据,  建议尽量不要再通过key的引用直接修改key,  有可能会无法 再操作这个数据 (了解)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写了hashCode和equals。则两个对象的hashCode是一样的。落在了数组上的同一个位置。</span></span><br><span class="line"><span class="comment">// 如果这时候通过了原对象的引用去修改了变量值。则会导致一个现象。hashCode会改变。不会落在同一个位置。则操作不会生效，比如remove。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议： Map里面的key, 直接用String.</span></span><br></pre></td></tr></table></figure>

<h3 id="（重要）HashMap的添加流程"><a href="#（重要）HashMap的添加流程" class="headerlink" title="&#x3D;&#x3D;（重要）HashMap的添加流程&#x3D;&#x3D;"></a>&#x3D;&#x3D;（重要）<span style="color:red;">HashMap的添加流程</span>&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.当我们想往一个HashMap中添加一个数据。 key=zs,value=20</span></span><br><span class="line"><span class="comment">// 2.对key计算它的hash。 也就是对zs取hash。</span></span><br><span class="line"><span class="comment">// 		计算hash的方法：(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">// 3.使用计算得到的hash。与数组长度取余，得到这个key在数组上的位置</span></span><br><span class="line"><span class="comment">// 		a%b=a&amp;(b-1)</span></span><br><span class="line"><span class="comment">// 4.检查数组位置上是否有键值对。</span></span><br><span class="line"><span class="comment">//   4.1 如果数组上没有元素，则直接新建节点，然后插入到数组。</span></span><br><span class="line"><span class="comment">//  				Node   key,value,hash,next(Node)</span></span><br><span class="line"><span class="comment">//   4.2 如果数组位置有元素，比较是否相等。</span></span><br><span class="line"><span class="comment">//  			怎么判断相等：p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span></span><br><span class="line"><span class="comment">//    1)如果相等，则直接使用新的value替代旧的value。结束</span></span><br><span class="line"><span class="comment">//	  2)如果不相等，则挨个进行比较。   链表直接调用next，树就是左小右大。一直比较到没有元素。</span></span><br><span class="line"><span class="comment">//	  		一直到最后一个。</span></span><br><span class="line"><span class="comment">// 5.如果是链表，插入后的长度超过阈值(8)。则会转化为红黑树</span></span><br><span class="line"><span class="comment">//		如果数组长度小于64。不会转化为红黑树，会直接进行扩容。</span></span><br><span class="line"><span class="comment">// 6.如果没有重复，插入后，map中节点数超过阈值。 默认为数组长度的0.75。则会进行扩容，扩容2倍。</span></span><br><span class="line"><span class="comment">// 		扩容后的位置： x或x+len 。len为数组的长度。  </span></span><br><span class="line"><span class="comment">// 7.上述所有的扩容, 都有可能导致原本数组某个位置如果有红黑树, 红黑树被拆成两部分(低位和高位), 任一位置结点数变少, 又有可能导致红黑树转化为链表</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如现在，我想往HashMap中添加一组键值对   zs,18</span></span><br><span class="line"><span class="comment">// 1.计算得到一个int值。</span></span><br><span class="line"><span class="comment">// (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br><span class="line"><span class="comment">// 2.对数组长度进行取余。  a% b = a &amp; (b-1)</span></span><br><span class="line"><span class="comment">// 3.1.判断数组位置是否存在数据，如果没有，直接将 key-value放入</span></span><br><span class="line"><span class="comment">// Node （key value hash next）</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 3.2如果数组位置有元素，判断是否相等。</span></span><br><span class="line"><span class="comment">// hashCode相等  &amp;&amp; (key的引用相等  ||  key equals（）为true。)</span></span><br><span class="line"><span class="comment">//	4.1如果相等。使用新值去替代旧值，返回旧值</span></span><br><span class="line"><span class="comment">// 4.2 如果不相等。 继续往下比较。链表， 红黑树。  链表就按next； 红黑树，按照左小右大的顺序来找</span></span><br><span class="line"><span class="comment">// 5.如果找到了最后，还是不相等。把它放到末尾。如果是链表，链表的长度如果大于8到达9，可能会由链表转换为红黑树。</span></span><br><span class="line"><span class="comment">// 如果数组的长度，小于64，直接扩容</span></span><br><span class="line"><span class="comment">// 6.上述如果添加了数据，有可能会导致扩容。  HashMap上的键值对，超过阈值（0.75 * 数组长度），会扩容</span></span><br><span class="line"><span class="comment">// x位置的元素，扩容后的位置： x，  x+oldCapacity    </span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除方法</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 查找方法</span></span><br><span class="line"><span class="comment">// 把添加流程弄懂，其他的流程很好弄懂。</span></span><br></pre></td></tr></table></figure>

<h2 id="HashMap的构造方法"><a href="#HashMap的构造方法" class="headerlink" title="HashMap的构造方法"></a>HashMap的构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap() </span><br><span class="line">          构造一个具有默认初始容量 (<span class="number">16</span>) 和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。 </span><br><span class="line">HashMap(<span class="type">int</span> initialCapacity) </span><br><span class="line">          构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。 会找到大于等于当前值的一个<span class="number">2</span>的幂次方</span><br><span class="line">HashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor) </span><br><span class="line">          构造一个带指定初始容量和加载因子的空 HashMap。 </span><br><span class="line">HashMap(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) </span><br><span class="line">          构造一个映射关系与指定 Map 相同的新 HashMap。</span><br></pre></td></tr></table></figure>

<h2 id="HashMap的API"><a href="#HashMap的API" class="headerlink" title="HashMap的API"></a>HashMap的API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------新增，删除，查找数据接口</span></span><br><span class="line"><span class="comment">//    V put(K key, V value): 添加键值对</span></span><br><span class="line"><span class="comment">//    void putAll(Map&lt;? extends K,? extends V&gt; m)： 将一个map的所有键值对都放入这个map</span></span><br><span class="line"><span class="comment">//    V get(Object key)： 根据一个key，获取value，如果key不存在，返回null</span></span><br><span class="line"><span class="comment">//    V remove(Object key)： 删除map中所包含的这个key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    boolean containsKey(Object key): 判断map中是否包含这个key</span></span><br><span class="line"><span class="comment">//    boolean containsValue(Object value): 判断map中是否包含这个value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------辅助接口</span></span><br><span class="line"><span class="comment">//    void clear() : 清空map</span></span><br><span class="line"><span class="comment">//    boolean equals(Object o)： 判断两个map是否相等</span></span><br><span class="line"><span class="comment">//    int hashCode(): 返回此映射的哈希码值。</span></span><br><span class="line"><span class="comment">//    boolean isEmpty(): map中是否有元素</span></span><br><span class="line"><span class="comment">//    int size() ：返回键-值映射关系数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------视图方法</span></span><br><span class="line"><span class="comment">//    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()： 返回此映射中包含的映射关系的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Set&lt;K&gt; keySet()： 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Collection&lt;V&gt; values()： 返回此映射中包含的值的 Collection 视图。</span></span><br></pre></td></tr></table></figure>

<h2 id="组装数据"><a href="#组装数据" class="headerlink" title="组装数据"></a>组装数据</h2><p>有三个类，其中一个存着学生的一些信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一组学生数据，学生信息里有以下信息。</span></span><br><span class="line"><span class="comment">// (id, name, age, teacher_id)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一组班主任数据，有以下信息</span></span><br><span class="line"><span class="comment">// (id, name, age)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们这样认为：一个老师对应n个学生，一个学生只对应一个老师。</span></span><br><span class="line"><span class="comment">// 现在需求方需要一个数据，需要返回 班主任的信息，然后和对应班级同学的信息。</span></span><br><span class="line"><span class="comment">// 提供两份数据：</span></span><br><span class="line"><span class="comment">//        List&lt;Teacher&gt; teachers = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span>&#123;</span><br><span class="line">   Teacher teacher;  </span><br><span class="line">   List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Hashtable是Map接口的一个子实现</li>
<li>Hashtable底层结构是数组+链表 (和HashMap在jdk1.8之前是一样的)</li>
<li>底层数组默认的初始长度11 ; 默认的扩容机制 2倍+1 </li>
<li>存储元素无序</li>
<li>不允许存储重复的key:   (对key的重复的定义和HashMap一样)</li>
<li>不允许存储null作为key,   也不允许存储null作为value</li>
<li>线程安全</li>
<li>jdk1.0时候出现,  (HashMap是jdk1.2时候出现, HashMap的出现就是为了取代Hashtable的)</li>
</ol>
<p>ArrayList （1.2） vector （1.0）</p>
<p>Hashtable  仅限面试使用。</p>
<p>HashMap的红黑树，在1.8的时候才加上去。所以在1.8之前，两个的结构是一致的</p>
<p>一般面试官问，了解HashMap和Hashtable吗？ </p>
<p>说一下HashMap和Hashtable的区别？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先先说一下共同点</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>两个都是Map的子实现。都用来存储key-value数据</span><br><span class="line"><span class="number">2.</span>在<span class="number">1.8</span>之前，两者底层结构都是数组+链表。但在<span class="number">1.8</span>之后，HashMap变成了数组+链表+红黑树。</span><br><span class="line"><span class="number">3.</span>存储元素无序，都不能存储重复元素。HashMap允许存储<span class="literal">null</span>。Hashtable不允许存储<span class="literal">null</span></span><br><span class="line"><span class="comment">// 如果记得，你就答一下。如果不记得。可以直接跳过。</span></span><br><span class="line">    <span class="comment">// 不要在这想。如果忘记了，不要在这想太久，（比如想2min）</span></span><br><span class="line"><span class="number">4.</span>HashMap线程不安全，Hashtable线程安全。</span><br><span class="line"><span class="number">5.</span>HashMap在<span class="number">1.2</span>出现，就是为了替代Hashtable的。新写代码不使用Hashtable</span><br></pre></td></tr></table></figure>

<p>面试答问题，要往自己熟悉的上面引。不要瞎引。</p>
<p>面试官问你一个问题，<span style="font-size:20px;color:red;">你要把自己熟悉的都答出来，不要面试官问你什么你就答什么，这样会很被动。</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不能面试官问你，了解这个吗。你说了解。</span><br><span class="line">面试官问你使用过这个吗。你说使用过。</span><br><span class="line"></span><br><span class="line">面试官问你这个，是想让你说你的认识。不是想听你回答了解，使用过这些的。大家要注意。</span><br></pre></td></tr></table></figure>

<p>1.掌握先大后小顺序。先把整体的印象答出来。比如是谁的接口，用来干什么。</p>
<p>答好了之后，再答细节。切记上来就开始答细节。</p>
<p>2.要有逻辑。不要左答一点，右答一点。面试是向面试官展示你思考方式的机会。</p>
<p>不是说面试官提了10个题，你答了9个。就通过了。</p>
<p>面试官是试图通过这10个题，了解你的基础，了解你解问题的思路。了解你的潜力。</p>
<p><span style=color:yellow;background:red><strong>切记。。。</strong></span></p>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><h2 id="LinkedHashMap的特点"><a href="#LinkedHashMap的特点" class="headerlink" title="LinkedHashMap的特点"></a>LinkedHashMap的特点</h2><ol>
<li>LinkedHashMap是HashMap的一个子类</li>
<li>LinkedHashMap底层基本上完全复用了父类HashMap的结构&#x2F;参数&#x2F;方法</li>
<li>LinkedHashMap在HashMap的基础上, <span style=color:red;background:yellow><strong>额外的维护了一个双向链表, 以保证迭代顺序</strong></span></li>
<li>LinkedHashMap存储<span style=color:red;background:yellow><strong>元素有序</strong></span></li>
<li>LinkedHashMap不允许存储重复数据（怎么定义重复）</li>
<li>LinkedHashMap允许存储null</li>
</ol>
<h2 id="LinkedHashMap的构造方法"><a href="#LinkedHashMap的构造方法" class="headerlink" title="LinkedHashMap的构造方法"></a>LinkedHashMap的构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap() </span><br><span class="line">          构造一个带默认初始容量 (<span class="number">16</span>) 和加载因子 (<span class="number">0.75</span>) 的空插入顺序 LinkedHashMap 实例。 </span><br><span class="line">LinkedHashMap(<span class="type">int</span> initialCapacity) </span><br><span class="line">          构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空插入顺序 LinkedHashMap 实例。 </span><br><span class="line">LinkedHashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor) </span><br><span class="line">          构造一个带指定初始容量和加载因子的空插入顺序 LinkedHashMap 实例。 </span><br><span class="line">LinkedHashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder) </span><br><span class="line">          构造一个带指定初始容量、加载因子和排序模式的空 LinkedHashMap 实例。 </span><br><span class="line">LinkedHashMap(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) </span><br><span class="line">          构造一个映射关系与指定映射相同的插入顺序 LinkedHashMap 实例。 </span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap的api"><a href="#LinkedHashMap的api" class="headerlink" title="LinkedHashMap的api"></a>LinkedHashMap的api</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------新增，删除，查找数据接口</span></span><br><span class="line"><span class="comment">//    V put(K key, V value): 添加键值对</span></span><br><span class="line"><span class="comment">//    void putAll(Map&lt;? extends K,? extends V&gt; m)： 将一个map的所有键值对都放入这个map</span></span><br><span class="line"><span class="comment">//    V get(Object key)： 根据一个key，获取value，如果key不存在，返回null</span></span><br><span class="line"><span class="comment">//    V remove(Object key)： 删除map中所包含的这个key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    boolean containsKey(Object key): 判断map中是否包含这个key</span></span><br><span class="line"><span class="comment">//    boolean containsValue(Object value): 判断map中是否包含这个value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------辅助接口</span></span><br><span class="line"><span class="comment">//    void clear() : 清空map</span></span><br><span class="line"><span class="comment">//    boolean equals(Object o)： 判断两个map是否相等</span></span><br><span class="line"><span class="comment">//    int hashCode(): 返回此映射的哈希码值。</span></span><br><span class="line"><span class="comment">//    boolean isEmpty(): map中是否有元素</span></span><br><span class="line"><span class="comment">//    int size() ：返回键-值映射关系数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------视图方法</span></span><br><span class="line"><span class="comment">//    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()： 返回此映射中包含的映射关系的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Set&lt;K&gt; keySet()： 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">//    Collection&lt;V&gt; values()： 返回此映射中包含的值的 Collection 视图。</span></span><br></pre></td></tr></table></figure>

<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><h2 id="TreeMap的特点"><a href="#TreeMap的特点" class="headerlink" title="TreeMap的特点"></a>TreeMap的特点</h2><ol>
<li>TreeMap是Map接口的子实现</li>
<li>TreeMap的数据结构红黑树。（左小右大）</li>
<li>TreeMap存储数据大小有序。</li>
<li>TreeMap不允许存储重复的key (什么叫重复: key的大小一样)</li>
<li>TreeMap不允许存储null作为key:   null没有办法比较大小</li>
</ol>
<h2 id="TreeMap的构造方法"><a href="#TreeMap的构造方法" class="headerlink" title="TreeMap的构造方法"></a>TreeMap的构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">构造方法摘要 </span><br><span class="line">TreeMap() </span><br><span class="line">          使用键的自然顺序构造一个新的、空的树映射。 </span><br><span class="line">TreeMap(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator) </span><br><span class="line">          构造一个新的、空的树映射，该映射根据给定比较器进行排序。 </span><br><span class="line">TreeMap(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) </span><br><span class="line">          构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的自然顺序 进行排序。 </span><br><span class="line">TreeMap(SortedMap&lt;K,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) </span><br><span class="line">          构造一个与指定有序映射具有相同映射关系和相同排序顺序的新的树映射。 </span><br></pre></td></tr></table></figure>

<h2 id="TreeMap的api"><a href="#TreeMap的api" class="headerlink" title="TreeMap的api"></a>TreeMap的api</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// ----------------------从Map接口继承来的----------------------------</span></span><br><span class="line"><span class="comment">//        boolean containsKey(Object key)</span></span><br><span class="line"><span class="comment">//        如果此映射包含指定键的映射关系，则返回 true。</span></span><br><span class="line"><span class="comment">//        boolean containsValue(Object value)</span></span><br><span class="line"><span class="comment">//        如果此映射为指定值映射一个或多个键，则返回 true。</span></span><br><span class="line"><span class="comment">//        V put(K key, V value)</span></span><br><span class="line"><span class="comment">//        将指定值与此映射中的指定键进行关联。</span></span><br><span class="line"><span class="comment">//        void putAll(Map&lt;? extends K,? extends V&gt; map)</span></span><br><span class="line"><span class="comment">//        将指定映射中的所有映射关系复制到此映射中。</span></span><br><span class="line"><span class="comment">//        V remove(Object key)</span></span><br><span class="line"><span class="comment">//        如果此 TreeMap 中存在该键的映射关系，则将其删除。</span></span><br><span class="line"><span class="comment">//        V get(Object key)</span></span><br><span class="line"><span class="comment">//        返回指定键所映射的值，如果对于该键而言，此映射不包含任何映射关系，则返回 null。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        void clear()</span></span><br><span class="line"><span class="comment">//        从此映射中移除所有映射关系。</span></span><br><span class="line"><span class="comment">//        Object clone()</span></span><br><span class="line"><span class="comment">//        返回此 TreeMap 实例的浅表副本。</span></span><br><span class="line"><span class="comment">//        int size()</span></span><br><span class="line"><span class="comment">//        返回此映射中的键-值映射关系数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Collection&lt;V&gt; values()</span></span><br><span class="line"><span class="comment">//        返回此映射包含的值的 Collection 视图。</span></span><br><span class="line"><span class="comment">//        Set&lt;K&gt; keySet()</span></span><br><span class="line"><span class="comment">//        返回此映射包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">//        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span></span><br><span class="line"><span class="comment">//        返回此映射中包含的映射关系的 Set 视图。      </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ------------------------TreeMap定义大小操作相关的api------------------------</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; ceilingEntry(K key): 大于等于给定key的最小键值对</span></span><br><span class="line"><span class="comment">//        K ceilingKey(K key): 大于等于给定key的最小key</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; floorEntry(K key): 小于等于key的最大的键值对</span></span><br><span class="line"><span class="comment">//        K floorKey(K key): 小于等于key最大的key</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; higherEntry(K key): 大于给定key的最小键值对</span></span><br><span class="line"><span class="comment">//        K higherKey(K key): 大于给定key的最小key</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; lowerEntry(K key): 小于key的最大的键值对</span></span><br><span class="line"><span class="comment">//        K lowerKey(K key): 小于key最大的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; firstEntry(): 返回最小的键值对</span></span><br><span class="line"><span class="comment">//        K firstKey(): 返回最小的key</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; lastEntry(): 返回最大的键值对</span></span><br><span class="line"><span class="comment">//        K lastKey(): 返回最大的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; pollFirstEntry(): 删除最小的键值对</span></span><br><span class="line"><span class="comment">//        Map.Entry&lt;K,V&gt; pollLastEntry(): 删除最大的键值对</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------视图方法-----------------------------</span></span><br><span class="line"><span class="comment">//        NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键的范围从 fromKey 到 toKey。</span></span><br><span class="line"><span class="comment">//        SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</span></span><br><span class="line"><span class="comment">//        SortedMap&lt;K,V&gt; tailMap(K fromKey)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键大于等于 fromKey。</span></span><br><span class="line"><span class="comment">//        NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。</span></span><br><span class="line"><span class="comment">//        SortedMap&lt;K,V&gt; headMap(K toKey)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键值严格小于 toKey。</span></span><br><span class="line"><span class="comment">//        NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</span></span><br><span class="line"><span class="comment">//        返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------一些特殊的api: 了解-------------------------------</span></span><br><span class="line"><span class="comment">//        NavigableSet&lt;K&gt; descendingKeySet()</span></span><br><span class="line"><span class="comment">//        返回此映射中所包含键的逆序 NavigableSet 视图。</span></span><br><span class="line"><span class="comment">//        NavigableMap&lt;K,V&gt; descendingMap()</span></span><br><span class="line"><span class="comment">//        返回此映射中所包含映射关系的逆序视图。</span></span><br><span class="line"><span class="comment">//        NavigableSet&lt;K&gt; navigableKeySet()</span></span><br><span class="line"><span class="comment">//        返回此映射中所包含键的 NavigableSet 视图。</span></span><br><span class="line"><span class="comment">//        Comparator&lt;? super K&gt; comparator()</span></span><br><span class="line"><span class="comment">//        返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。</span></span><br></pre></td></tr></table></figure>



<p>假设我们需要实现一个功能，即存储某个城市的天气预报，并且需要按照时间排序。在这种情况下，我们可以使用TreeMap来存储天气预报信息。</p>
<p>具体来说，我们可以将预报时间作为key，将天气预报信息（如温度<a href="javascript:;">temperature</a>、湿度<a href="javascript:;">humidity</a>、气压<a href="javascript:;">air_pressure</a>等）作为value存储在TreeMap中。由于TreeMap是有序的，因此我们可以方便地按照时间顺序遍历元素，从而实现预报信息的展示和查询功能。</p>
<p>想根据 2023-04-24这天的天气。</p>
<p>想获取  17-23号的天气。</p>
<p>如果需要Map中的key，有序的时候，可以使用这个TreeMap。</p>
<p>map.subMap(new Date(“2023-04-17”), true,new Date(“2023-04-24”), false)</p>
<p>&#x2F;&#x2F; HashMap   + ArrayList  </p>
<p>&#x2F;&#x2F; 要了解 ArrayList和HashMap的常见操作，时间复杂度。</p>
<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><p>在工作中，还会用到。需要掌握。 一般都是使用它来从properties配置文件中读取信息，其他的不用它。</p>
<p>Hashtable的子类</p>
<p>当做配置文件使用，只能存入String类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，只能存入String类型的key，value。否则在存储为properties文件的时候，会报错</span></span><br><span class="line"><span class="comment">// 新增key,value 使用的方法</span></span><br><span class="line">setProperty()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据key查询value的方法，使用</span></span><br><span class="line">getProperty()</span><br></pre></td></tr></table></figure>



<p>properties文件(1.properties)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key=value 格式去写</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">zhangsan</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br></pre></td></tr></table></figure>



<p>读取properties文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties1.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.properties&quot;</span>));</span><br></pre></td></tr></table></figure>








    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Map/" rel="tag"># Map</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/2-Collection/" rel="prev" title="2_Collection">
                  <i class="fa fa-angle-left"></i> 2_Collection
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/4-Stream%E6%B5%81/" rel="next" title="4_Stream流">
                  4_Stream流 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">染星辰</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
